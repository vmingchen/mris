\section{Introduction}
\label{intro}

In many scenarios of storage systems, the access patterns and the
sizes of structured objects presents a property that matches the
property of the storage hierarchy. For example, in an image storage
system, the attributes and thumbnails of stored images are small in
size but frequently accessed, which makes them fits well in small but
fast and expensive top-tiered storage devices, such as NVRAM and
Flash.  Whereas the original images are big but less accessed, which
makes them suitable for large but slow and inexpensive bottom-tiered
storage devices, such as HDD and tape.  Moreover, slow seeks can
usually be amortized by fast sequential access followed.

For small objects, throughput is important in term of op/sec. They
tend to be accessed randomly because of their small sizes and the
implication that they are likely to be thumbnails, metadata and
attributes.  Top-tiered devices, e.g., NVRAM, exhibit great IOPS
performance, and they allow storage to be used in finer granularity
which causes less inner fragmentation as well. But for large objects,
throughput is more important in terms of mb/s. Their I/Os tend to be
sequential as well. Bottom-tiered devices, e.g., HDD, are large in
capacity and exhibit satisfactory throughput for sequential I/Os. 

When objects present such a size-tiered property, a corresponding
size-tiered storage system can provide good trade-off between cost and
performance as it gets the best from different tiers of the storage
hierarchy. Size-tiered storage system is also able to support the
popular out-of-place update optimization, as in log-structured
filesystems, by turning small in-place updates to revision logs as
metadata and compacting them into large batched I/O to bottom tiers.

Since multimedia files are primarily accessed sequentially, it may not
be necessary to provide for efficient random access to every large
file \cite{evans2002study}.  Facebook researchers also argued that it
may even be worthwhile to investigate not caching large objects in the
memory at all, to increase overall cache hit rates
\cite{kvworkload_sigmetrics}.  We implemented a size-tiered object
storage system optimized for multi-resolution images, named MRIS
(Multi-Resolution Image Store).  MRIS aims at storing large amount of
images, as well as their metadata and smaller versions (such as
thumbnails), efficiently. However, the strageties emploied in MRIS can
be applied to other storage and web-serving systems as well because
there also exist salient size characteristics following power-law
distributions~\cite{kvworkload_sigmetrics}.

%We plan to use KVDB, which can be aware of multi-tier storage
%techniques as indicated in Rick's SOCC11 paper (GTSSL), as the
%infrastructure for MRIS. KVDB can also provide us with favorable extra
%functions including transaction, snapshotting and versioning.
%Hopefully, we can turn these functions to configurable features of
%MRIS, which can therefore be more flexible.

%\NOTE{mchen}{Test footnote. }
%\texttt{newread(\textsl{ptr}, \textsl{username})}
%\begin{verbatim}
%int read(int fd, ...)
%{
%  return 0;
%}
%\end{verbatim}

The rest of the paper is organized as follows. Section
\ref{sec:implementation} describe our design and implementation.
%Section \ref{sec:trace} presents the study Wikipedia's image requests
%and showes the size-tiered property in its workloads.  
We evaluate the performance of our system in Section \ref{sec:eval}.
We analyze related work in Section \ref{sec:related} and conclude our
work in Section \ref{sec:conc}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% For Emacs:
% Local variables:
% fill-column: 70
% End:
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% For Vim:
% vim:textwidth=70 noai nocin nosi
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% LocalWords:  
